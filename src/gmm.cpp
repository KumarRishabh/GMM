#include <ros/ros.h>
#include <image_transport/image_transport.h>
#include <cv_bridge/cv_bridge.h>
#include <std_msgs/Int64MultiArray.h>

#include "opencv2/imgcodecs.hpp"
#include "opencv2/imgproc.hpp"
#include "opencv2/videoio.hpp"
#include <opencv2/highgui.hpp>
#include <opencv2/video.hpp>
#include <bits/stdc++.h>

using namespace cv;
using namespace std;

// Global variables
ros::Publisher pub_n;

Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
static Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor

/**
 * @function processVideo
 */
void processVideo(Mat img) {

        std_msgs::Int64MultiArray vertices;

        Mat img_hsv;
        cvtColor(img,img_hsv, CV_BGR2HSV);

        Mat red_buoy(img.rows,img.cols,CV_8UC1);
        Mat red_hsv(img.rows,img.cols,CV_8UC1);

        for (int i = 0; i < img.rows; i++)
	      {
            for (int j = 0; j < img.cols; j++)
            {
              //  h = get_h((int)img_hsv.at<Vec3b>(i,j)[0],(int)img_hsv.at<Vec3b>(i,j)[1],(int)img_hsv.at<Vec3b>(i,j)[2]);
                if((int)fgMaskMOG2.at<uchar>(i,j)==255 && (int)img_hsv.at<Vec3b>(i,j)[0] > 150)
                {
                    red_buoy.at<uchar>(i,j)=255;
                }
                else  red_buoy.at<uchar>(i,j)= 0 ;

                red_hsv.at<uchar>(i,j) = (int)img_hsv.at<Vec3b>(i,j)[0];
            }
        }

        imshow("red_buoy",red_buoy);

        GaussianBlur(red_buoy,red_buoy,Size(15,15),2,2);

        vector<vector<Point> > contours;
        vector<Vec4i> hierarchy;

        findContours(red_buoy, contours, hierarchy, RETR_CCOMP,CHAIN_APPROX_SIMPLE);

        if(contours.size() != 0)
        {
            /// Draw contours

            Mat drawing = Mat::zeros( red_buoy.size(), CV_8UC3 );
            Mat dst = Mat::zeros( red_buoy.size(), CV_8UC3 );

            int idx = 0, largestComp = 0;
            double maxArea = 0;

            vector<Point2f>center( contours.size() );
            vector<float>radius( contours.size() );
            vector<vector<Point> > contours_poly( contours.size() );
            Point2f vertex;
            Point2f vertex_opp;

            for( ; idx >= 0; idx = hierarchy[idx][0] )
            {
                const vector<Point>& c = contours[idx];
                double area = fabs(contourArea(Mat(c)));
                if( area > maxArea )
                {
                    maxArea = area;
                    largestComp = idx;
                }
                
                approxPolyDP( Mat(contours[idx]), contours_poly[idx], 3, true );
                minEnclosingCircle( (Mat)contours_poly[idx], center[idx], radius[idx] );
            }
            
            Scalar color( 0, 0, 255 );
            
            vertex.y = center[largestComp].y - radius[largestComp];
            vertex.x = center[largestComp].x - radius[largestComp];
            vertex_opp.y = center[largestComp].y + radius[largestComp];
            vertex_opp.x = center[largestComp].x + radius[largestComp];
            drawContours( dst, contours, largestComp, color, FILLED, LINE_8, hierarchy );
            rectangle( drawing, vertex, vertex_opp , color, 2, 8, 0 );
            circle( drawing, center[largestComp], (int)radius[largestComp], color, 2, 8, 0 );
            imshow("contours",drawing);

            vertices.data.push_back(center[largestComp].y);
         	  vertices.data.push_back(center[largestComp].x);
         	  vertices.data.push_back(radius[largestComp]);

            ROS_INFO("Values sent to topic-print\n");
            pub_n.publish(vertices);
        }

        else return;
}


/**
  * @function call
  */
void call(const sensor_msgs::ImageConstPtr& msg){

  ROS_INFO("IMAGE RECIEVED\n");
  cv_bridge::CvImagePtr cv_ptr;

  //create Background Subtractor objects
  //pMOG2 = createBackgroundSubtractorMOG2(); //MOG2 approach

  cv_ptr = cv_bridge::toCvCopy(msg, sensor_msgs::image_encodings::BGR8);
  Mat img = cv_ptr->image;
  //update the background model
  pMOG2->apply(img, fgMaskMOG2);

  processVideo(img);

  imshow("FG Mask MOG 2", fgMaskMOG2);
  imshow("Frame", img);
  waitKey(10);

}

/*
 * @function main
 */

int main(int argc, char** argv) {

  pMOG2 = createBackgroundSubtractorMOG2();
  ros::init(argc, argv, "object_detect1");
  ros::NodeHandle nh;
  image_transport::ImageTransport it(nh);

  pub_n = nh.advertise<std_msgs::Int64MultiArray>("state", 1);

  ros::Rate loop_rate(10);

  image_transport::Subscriber image_sub_ = it.subscribe("input", 1, call);

  ros::spin();
  return 0;
 }
